# hw_layer.py

import time
import statistics
from gpiozero import Device, Buzzer, Button, DistanceSensor
from gpiozero.pins.lgpio import LGPIOFactory

# I2C libraries (only needed for OLED now)
import board
import busio
from luma.core.interface.serial import i2c
from luma.core.render import canvas
from luma.oled.device import ssd1306

# --- Set the modern pin factory for the Pi 5 ---
try:
    Device.pin_factory = LGPIOFactory()
    print("INFO: Successfully set pin factory to lgpio for Raspberry Pi 5.")
except Exception as e:
    print("--- FATAL ERROR ---")
    print("Could not set the lgpio pin factory. Ensure 'python3-lgpio' is installed.")
    print(f"Error: {e}")
    exit()

# --- HARDWARE PIN CONFIGURATION ---
ULTRASONIC_TRIG_PIN = 23
ULTRASONIC_ECHO_PIN = 24
BUZZER_PIN = 18
BUTTON_PIN = 17

# --- HARDWARE INITIALIZATION ---

# Declare all variables as None first
oled_device = None
distance_sensor_obj = None
buzzer_obj = None
button_obj = None

# Attempt to initialize OLED Display
try:
    oled_serial = i2c(port=1, address=0x3C)
    oled_device = ssd1306(oled_serial)
    print("INFO: OLED Display (SSD1306) initialized successfully.")
except Exception as e:
    print(f"WARNING: Could not initialize OLED Display. It may be disconnected. Error: {e}")

# Attempt to initialize GPIO Devices
try:
    distance_sensor_obj = DistanceSensor(echo=ULTRASONIC_ECHO_PIN, trigger=ULTRASONIC_TRIG_PIN)
    buzzer_obj = Buzzer(BUZZER_PIN)
    button_obj = Button(BUTTON_PIN, pull_up=True)
    print("INFO: GPIO Devices (Ultrasonic, Buzzer, Button) initialized successfully.")
except Exception as e:
    print(f"ERROR: A GPIO device could not be initialized. Check wiring. Error: {e}")


# --- CORE HARDWARE FUNCTIONS ---

def buzzer_beep(duration):
    if buzzer_obj:
        buzzer_obj.beep(on_time=duration, n=1)

def read_button(): # Retained for future use
    if button_obj:
        return not button_obj.is_pressed
    return True

def measure_distance(samples=10):
    if not distance_sensor_obj:
        return 0, 0
    readings = []
    for _ in range(samples):
        time.sleep(0.01)
        distance_cm = distance_sensor_obj.distance * 100
        if 2 < distance_cm < 400:
            readings.append(distance_cm)
    if not readings:
        return 0, 0
    avg = round(statistics.mean(readings), 2)
    std_dev = round(statistics.stdev(readings) if len(readings) > 1 else 0, 2)
    return avg, std_dev

# --- CALIBRATED ANALYSIS FUNCTIONS ---

def analyze_absorption(sigma):
    """
    Classifies material based on your calibrated threshold.
    """
    # Your calibrated value is now integrated here.
    if sigma > 0.096:
        return "High"  # Likely Absorbent
    else:
        return "Low"   # Likely Reflective

def update_physical_oled(distance, shape, material):
    if oled_device:
        try:
            with canvas(oled_device) as draw:
                draw.text((0, 0), f"Dist: {distance}", fill="white")
                draw.text((0, 12), f"Shape: {shape}", fill="white")
                draw.text((0, 24), f"Mat: {material}", fill="white")
        except Exception as e:
            print(f"Error writing to OLED: {e}")
    else:
        # Fallback to console if OLED is disconnected
        print(f"--- OLED Sim ---\nDist: {distance}\nShape: {shape}\nMat: {material}\n----------------")
